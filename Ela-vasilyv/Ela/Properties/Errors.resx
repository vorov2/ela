<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Compile_AssignImmutableVariable" xml:space="preserve">
    <value>Unable to change a value of an immutable variable '{0}'.</value>
  </data>
  <data name="Compile_BreakNotAllowed" xml:space="preserve">
    <value>Break expression is not allowed here.</value>
  </data>
  <data name="Compile_ContinueNotAllowed" xml:space="preserve">
    <value>Continue expression is not allowed here.</value>
  </data>
  <data name="Compile_ExpressionNotAllowed" xml:space="preserve">
    <value>Expression is not allowed in this context.</value>
  </data>
  <data name="Compile_InvalidCoroutine" xml:space="preserve">
    <value>Invalid coroutine declaration body.</value>
  </data>
  <data name="Compile_InvalidExpressionForInitializer" xml:space="preserve">
    <value>This expression can't be used in initializer without the explicit field name specification.</value>
  </data>
  <data name="Compile_NoInitForVar" xml:space="preserve">
    <value>Variables cannot be declared without initialization.</value>
  </data>
  <data name="Compile_PlaceholderNotValid" xml:space="preserve">
    <value>An expression "_" is not valid in this context.</value>
  </data>
  <data name="Compile_ReturnInCoroutine" xml:space="preserve">
    <value>Return expression is not allowed in coroutine.</value>
  </data>
  <data name="Compile_UnableAssignExpression" xml:space="preserve">
    <value>Unable to assign a value to an expression.</value>
  </data>
  <data name="Compile_UndefinedVariable" xml:space="preserve">
    <value>Undefined variable '{0}'.</value>
  </data>
  <data name="Compile_VariableAlreadyDeclared" xml:space="preserve">
    <value>Variable '{0}' is already declared.</value>
  </data>
  <data name="Compile_YieldNotAllowed" xml:space="preserve">
    <value>Yield expression is not allowed in this context.</value>
  </data>
  <data name="Hint_DefaultPatternToEnd" xml:space="preserve">
    <value>Move a pattern that matches any value (such as '_' or variable declaration) to the end of the match.</value>
  </data>
  <data name="Hint_UseIgnoreToPop" xml:space="preserve">
    <value>Use ignore expression to disable warning, i.e. 'ignore x'</value>
  </data>
  <data name="Hint_UseVarInsteadLet" xml:space="preserve">
    <value>Use 'var' keyword to declare a mutable variable.</value>
  </data>
  <data name="Hint_UseYieldToReturn" xml:space="preserve">
    <value>Use 'yield' expression in order to return a value from coroutine.</value>
  </data>
  <data name="Linker_InvalidModule" xml:space="preserve">
    <value>Unable to link module '{0}'. Module is invalid.</value>
  </data>
  <data name="Linker_UnresolvedModule" xml:space="preserve">
    <value>Unable to find referenced module '{0}'.</value>
  </data>
  <data name="Runtime_ConversionFailed" xml:space="preserve">
    <value>Conversion from '{0}' to '{1}' failed because of the following reason: {2}.</value>
  </data>
  <data name="Runtime_DivideByZero" xml:space="preserve">
    <value>Division by zero.</value>
  </data>
  <data name="Runtime_InvalidOperation" xml:space="preserve">
    <value>Unable to perform operation '{0}' on types '{1}' and '{2}'.</value>
  </data>
  <data name="Runtime_InvalidType" xml:space="preserve">
    <value>Invalid type. Expected: '{0}', got: '{1}'.</value>
  </data>
  <data name="Runtime_MatchFailed" xml:space="preserve">
    <value>Match failed. None of the patterns were successful.</value>
  </data>
  <data name="Runtime_NotFunction" xml:space="preserve">
    <value>Value is not a function.</value>
  </data>
  <data name="Runtime_TooFewParameters" xml:space="preserve">
    <value>Not all of the parameters are specified in a function call.</value>
  </data>
  <data name="Runtime_TooManyParameters" xml:space="preserve">
    <value>Too many parameters specified in a function call.</value>
  </data>
  <data name="Runtime_UnableToCallAsFunction" xml:space="preserve">
    <value>Unable to call a specified value as a function. Invalid function handle.</value>
  </data>
  <data name="Runtime_UnableToConvert" xml:space="preserve">
    <value>Unable to convert type '{0}' to '{1}'.</value>
  </data>
  <data name="Runtime_Unknown" xml:space="preserve">
    <value>An unknown runtime error has occured. Error details: {0}.</value>
  </data>
  <data name="Runtime_UnknownField" xml:space="preserve">
    <value>There is no such mutable field as '{0}' in the target object.</value>
  </data>
  <data name="Warning_ExpressionValueNotUsed" xml:space="preserve">
    <value>Value returned by this expression is not used.</value>
  </data>
  <data name="Warning_NextMatchEntryIgnored" xml:space="preserve">
    <value>This entry matches any value. All next match entries will be ignored.</value>
  </data>
  <data name="Parser_InvalidEscapeCode" xml:space="preserve">
    <value>Invalid escape sequence in a string at position '{0}'.</value>
  </data>
  <data name="Parser_InvalidIntegerLiteral" xml:space="preserve">
    <value>Invalid integer literal.</value>
  </data>
  <data name="Parser_InvalidRealLiteral" xml:space="preserve">
    <value>Invalid real literal.</value>
  </data>
  <data name="Parser_UnknownType" xml:space="preserve">
    <value>Unknown type '{0}'. An expression should one of the standard Ela types.</value>
  </data>
  <data name="Parser_SyntaxError" xml:space="preserve">
    <value>Syntax error: {0}.</value>
  </data>
  <data name="Parser_ExpectedToken" xml:space="preserve">
    <value>Syntax error, expected token: {0}.</value>
  </data>
  <data name="Parser_ExpectedElse" xml:space="preserve">
    <value>A conditional expression (if/else) is missing a required 'else' clause.</value>
  </data>
  <data name="Parser_ExpectedCatch" xml:space="preserve">
    <value>A try/catch/finally expression is missing a required 'catch' clause.</value>
  </data>
  <data name="Parser_InvalidExpression" xml:space="preserve">
    <value>Invalid expression. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidIdentifierItem" xml:space="preserve">
    <value>Invalid expression, an identifier was expected. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidItemAccess" xml:space="preserve">
    <value>Invalid expression, indexer, function call or member access was expected. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidMatchEntry" xml:space="preserve">
    <value>A syntax for a match entry is invalid. Match entry should start with a pipe '|' operator, followed by pattern, followed by '-&gt;' operator.</value>
  </data>
  <data name="Parser_InvalidPattern" xml:space="preserve">
    <value>Unable to recognize a pattern.</value>
  </data>
  <data name="Parser_InvalidStatement" xml:space="preserve">
    <value>Invalid left side expression. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidAssignment" xml:space="preserve">
    <value>Syntax for the assignment expression is invalid.</value>
  </data>
  <data name="Parser_InvalidVariableDeclaration" xml:space="preserve">
    <value>Invalid variable declaration expression. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidTryCatch" xml:space="preserve">
    <value>Syntax for the try/catch/finally expression is invalid.</value>
  </data>
  <data name="Parser_InvalidUnaryOp" xml:space="preserve">
    <value>Invalid unary operator.</value>
  </data>
  <data name="Parser_InvalidLiteral" xml:space="preserve">
    <value>Invalid or unknown literal. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidUnary" xml:space="preserve">
    <value>Invalid unary expression. Production: {0}.</value>
  </data>
  <data name="Parser_InvalidConversion" xml:space="preserve">
    <value>Invalid conversion expression. Conversion should start with a valid Ela type name, followed by a function call syntax.</value>
  </data>
  <data name="Parser_TableLiteralInvalidField" xml:space="preserve">
    <value>Invalid table literal. Table declarations should comply to the form field := expr where field is a valid identifier.</value>
  </data>
  <data name="Compile_FunctionLiteralInvalidParams" xml:space="preserve">
    <value>Invalid function literal. All function parameters if any should be valid identifiers. If function has more than one parameter all parameters should be enclosed in braces.</value>
  </data>
  <data name="Compile_FunctionLiteralInvalidHead" xml:space="preserve">
    <value>Invalid function literal. Function literals should comply to the form: n -&gt; expr or (n, ...) -&gt; expr or () -&gt; expr if a function doesn't have parameters.</value>
  </data>
  <data name="Compile_AssignExternalVariable" xml:space="preserve">
    <value>Unable to change a value of variable '{0}' declared in an external module.</value>
  </data>
  <data name="Compile_MatchInvalidHeadTailNil" xml:space="preserve">
    <value>A list nil constructor ([]) can only be used at the end of a pattern.</value>
  </data>
  <data name="Linker_InvalidExternalModule" xml:space="preserve">
    <value>Invalid foreign module '{0}'. A required module descriptor is missing.</value>
  </data>
  <data name="Linker_InvalidForeignModuleType" xml:space="preserve">
    <value>Foreign module '{0}' doesn't implement the required ForeignModule type.</value>
  </data>
  <data name="Compile_ReturnInGlobal" xml:space="preserve">
    <value>Return expression is allowed only inside functions.</value>
  </data>
  <data name="Parser_InvalidFunctionDeclaration" xml:space="preserve">
    <value>Invalid function declaration, function name is missing.</value>
  </data>
  <data name="Linker_InvalidModuleName" xml:space="preserve">
    <value>A name of the referenced module '{0}' contains illegal chars.</value>
  </data>
  <data name="Linker_ForeignModuleInitError" xml:space="preserve">
    <value>Unable to initialize foreign module '{0}' because of an error: {1}.</value>
  </data>
  <data name="Linker_AssemblyLoadError" xml:space="preserve">
    <value>Unable to load assembly '{0}' because of an error: {1}.</value>
  </data>
  <data name="Linker_DuplicateModuleInAssembly" xml:space="preserve">
    <value>Duplicate module name '{0}' in assembly '{1}'.</value>
  </data>
  <data name="Linker_ModuleNotFoundInAssembly" xml:space="preserve">
    <value>A module '{0}' is not defined in the assembly '{1}'.</value>
  </data>
  <data name="Linker_ObjectFileError" xml:space="preserve">
    <value>Unable to read object file '{0}' because of an error: {1}.</value>
  </data>
  <data name="Linker_WarningOutdatedObjectFile" xml:space="preserve">
    <value>An object file '{0}' is different from the source file '{1}'. Using the source file.</value>
  </data>
  <data name="Compile_StrictMutableGlobal" xml:space="preserve">
    <value>Unable to declare a mutable global scope variable when the strict mode is on.</value>
  </data>
  <data name="Parser_ShortMatchNoParams" xml:space="preserve">
    <value>Unable to use a short declaration of 'match' expression as a body for a function with no parameters.</value>
  </data>
  <data name="Runtime_UnknownNameReference" xml:space="preserve">
    <value>A reference to the unknown name '{0}'.</value>
  </data>
  <data name="Compile_BinaryOperatorTwoParams" xml:space="preserve">
    <value>Binary operator should have exactly two parameters.</value>
  </data>
  <data name="Compile_OperatorAlreadyDeclared" xml:space="preserve">
    <value>Operator '{0}' is already declared in this module.</value>
  </data>
  <data name="Compile_OperatorOnlyGlobal" xml:space="preserve">
    <value>Operators can be declared only in the global scope.</value>
  </data>
  <data name="Compile_UnaryOperatorOneParam" xml:space="preserve">
    <value>Unary operator should have a single parameter.</value>
  </data>
  <data name="Warning_OperatorAsMutable" xml:space="preserve">
    <value>You cannot redefine an operator, declare it as an immutable value using 'let'.</value>
  </data>
  <data name="Parser_ExpectedOperator" xml:space="preserve">
    <value>A name for an operator is invalid. It should be a unique combination of the following allowed symbols: '!%&amp;*+-.:/&lt;=&gt;?@^|~'.</value>
  </data>
  <data name="Parser_ExpectedSemicolon" xml:space="preserve">
    <value>A semicolon character (';') is expected.</value>
  </data>
  <data name="Runtime_IndexOutOfRange" xml:space="preserve">
    <value>Index was out of range.</value>
  </data>
  <data name="Runtime_CallError" xml:space="preserve">
    <value>An unexpected error occured during function call: {0}</value>
  </data>
  <data name="Runtime_InvalidParameterType" xml:space="preserve">
    <value>Invalid type for the function parameter. Expected '{0}', got '{1}'.</value>
  </data>
  <data name="Runtime_UndefinedVariable" xml:space="preserve">
    <value>A name '{0} is not defined in the target module.</value>
  </data>
  <data name="Runtime_PrivateVariable" xml:space="preserve">
    <value>The name '{0}' is declared as private and cannot be referenced.</value>
  </data>
  <data name="Runtime_UndefinedArgument" xml:space="preserve">
    <value>An argument with the name '{0}' is undefined.</value>
  </data>
  <data name="Runtime_UnknownParameterType" xml:space="preserve">
    <value>Invalid type for the function parameter: '{0}'.</value>
  </data>
  <data name="Compile_NoLetInConstructor" xml:space="preserve">
    <value>Constructors can be declared only using 'let' binding.</value>
  </data>
  <data name="Compile_InvalidBase" xml:space="preserve">
    <value>Cannot use 'base' keyword in this context.</value>
  </data>
  <data name="Compile_DeclarationInEmbedded" xml:space="preserve">
    <value>Embedded expression cannot be a variable declaration.</value>
  </data>
  <data name="Compile_NoInitForeach" xml:space="preserve">
    <value>Initialization expression is not allowed in for-in cycles.</value>
  </data>
  <data name="Compile_NoPatternMatchForTo" xml:space="preserve">
    <value>Pattern matching is not allowed in for-to and for-downto cycles.</value>
  </data>
  <data name="Compile_InvalidCtorBody" xml:space="preserve">
    <value>Last expression in a constructor declaration should be a tuple or record literal.</value>
  </data>
  <data name="Warning_MatchEntryAlwaysFail" xml:space="preserve">
    <value>A specified pattern will never match.</value>
  </data>
  <data name="Compile_BreakExecutionNotAllowed" xml:space="preserve">
    <value>This expression breaks execution and is not allowed in this context.</value>
  </data>
  <data name="Warning_VoidWillAlwaysFail" xml:space="preserve">
    <value>An expression is of type 'unit' and will always cause code to fail with an error.</value>
  </data>
  <data name="Compile_OrPatternNotAllVarsDeclared" xml:space="preserve">
    <value>When using 'or' pattern in match all cases should declare the same number of variables.</value>
  </data>
  <data name="Parser_ExpectedOn" xml:space="preserve">
    <value>Invalid match syntax: 'on' operator is required before each match entry.</value>
  </data>
  <data name="Parser_ExpectedMatchEntryArrow" xml:space="preserve">
    <value>Invalid match entry syntax: a '-&gt;' operator is required after pattern.</value>
  </data>
  <data name="Runtime_ExternalCallError" xml:space="preserve">
    <value>An unexpected error occured during external function call: {0}</value>
  </data>
  <data name="Compile_MatchEntryTypingFail" xml:space="preserve">
    <value>Data types of a match entry are incompatible with previous entries.</value>
  </data>
  <data name="Hint_MatchEntryTypingFailed" xml:space="preserve">
    <value>All entries in a match expression should use compatible type patterns, e.g. you can't use list pattern and array pattern at the same position in different entries.</value>
  </data>
  <data name="Runtime_ImmutableField" xml:space="preserve">
    <value>Unable to change a value of a field '{0}'.</value>
  </data>
  <data name="Runtime_OperationNotSupported" xml:space="preserve">
    <value>This operation is not supported by the object of type '{0}'.</value>
  </data>
</root>