#title What's new? (Ela Platform 2012.7)

=Elide changes
Elide is updated according to the new version of Ela. Also several new features were introduced. Here
is a short overview of changes:
* Ela object file viewer is updated and now display a list of all constructor symbols declared in a module.
* Outline view is refactored and now lists module members in a more convinient way. Class functions are grouped by classes. Also Outline view now uses different icons for private bindings. Lastly now itis possible to navigate from Outline not only to regular bindings, but also to types, classes and classfunctions.
* Now it is possible to create files directly from Explorer view.
* Ela and EIL syntax highlighting are updated according to language changes.
* A lot of small fixes and enhancements.

=Ela changes
Ela Platform 2012.7 is shipped with a new version of Ela - Ela 0.11.1. Ela 0.11.1 is enhancement and a 
stabilization for an initial release of 0.11. It also offers a new encoding for data types.

==Algebraic types
Ela 0.11 have introduced a concept of user defined types. In Ela 0.11.1 are presented in a more traditional
form of algebraic types. A simple type declaration is now written like so:
>>type Maybe = Nothing | Just a
Type constructors (separated by semicolons) are either constants, like `Nothing`, or functions, like `Just`.
In the latter case they can be treated just like any other regular Ela functions. A constructor can accept
an unlimited number of arguments; argument names should be valid Ela identifiers, but other than that, there
are no restrictions on them. Names are basically not processed by Ela compiler, but they become a part of
module metadata and are discoverable at runtime. For example, this might allow to treat products as records:
>>type Point = Point x y deriving Name
>>p = Point 12 24
>>p.y
Type name and constructor name can be the same, as you can from the definition of `Point` type above, however,
type names should always be uppercased. Constructors should be either uppercased or can also be declared in 
an infix form like so:
>>type Complex = a :+ a
And, of course, you can pattern match constructors.//br
Types (and individual constructors) also supports attributes, including visibility attributes. For more information
on algebraic types please refer to the language reference.

==Open types and decomission of variants
In Ela 0.11.1 a variant data type (inspired by polymorphic variants from OCaml) is decomissioned. Variant type
was used in Ela as a replacement for algebraic types. Currently a more proper encoding for algebraic types
exist. However, variants could be used to imitate open algebraic types, and that is the reason, why Ela 0.11.1
provides two additional declaration in addition to `type` declaration - `opentype` and `data`.//br
Syntax for `opentype` and `data` declarations is essentially the same as for `type` declarations:
>>opentype Point = Point x y
The major difference is that for a type, declared using `opentype`, one can add new constructors (new "cases")
afterwards using `data` declaration:
>>data Point = Point3D x y z
The definition above extends a type `Point` with a new constructor. If we remove declaration of `Point` data type,
it would fail with a compilation error.//br
More information is available in the language reference.

==Default and autogenerated instances
Ela 0.11.1 allows to declare default instances. The syntax for default instances is the same as regular instance
syntax, but with a type name omitted:
>>class MinMax a where
>>  maxValue a->a
>>  minValue a->a
>>
>>instance MinMax where
>>  maxValue x y 
>>   | x >= y = x 
>>   | else   = y
>>  minValue x y 
>>   | x <= y = x 
>>   | else   = y
A default instance can be complete or partial. Partial instance simply provides you "default" implementations of
some functions, which therefore can omitted when you write specific instance. Complete instances allows you to
provide a specific instance for a type with no function definitions at all:
>>instance MinMax Int
Such an instance is not really different from any regular instance definition and can be, for example, provided for
a built-in type or for a type from another module. Sometimes, however, it might be useful to specify a number of
instances at the point of declaration without the necessity to write boilerplate code. That is the reason, why
Ela 0.11.1 provides a special syntax sugar through `deriving` keyword:
>>type Foo = Foo a
>>  deriving Ord MinMax
You can specify any number of instance in the `deriving` clause, and this is essentially the same as providing a
separated instance declatation with an empty body. Also any class that has a discoverable default instance would
work. You can even write default instances for standard classes (such as `Eq`, `Ord`, `Show`, etc.). Also a single class
can have several default instances from different which would simply shadow each other.//br
Now Ela is shipped with `generic` module that provides complete default instance for most of standard classes.

==Flexible ranges
Previously Ela compiler manually emitted code for arithmetic ranges. This was the reason, why, in order to use a
custom type in a range, one would have to implement all comparison and numeric functions for it. For some types
(such as chars) support for ranges was reasonable, whole implementation of numeric operations didn't make sense.//br
Ela 0.11.1 goes in a different way and, instead of manually emitting code for ranges, extends a standard `Enum`
class with two functions - `enumFrom` and `enumFromTo`. The syntax of ranges is kept intact, but now ranges are
just syntax sugar for explicit application of functions `enumFrom` (ranges without upper bound) and `enumFromTo`
(ranges with upper bound). Therefore, if you want to support your own data type in ranges, you only need to 
implement to implement these two functions (in addition to `succ` and `pred` which were the members of `Enum`
class long before that). Moreover there is even a default instance of `Enum` class in `generic` module, so that
in most cases you just need to write `deriving Enum` to support ranges.

==Type checking
Ela up to 0.11 used to provide a special `is` pattern that was used for type checking. This was basically an
abuse of pattern matching concept, and finally Ela decomissions this pattern. However, type checking functionality
is still available and is now implement as a separate `is` expression:
>>x is Int
One can also test if a given value supports a list of provided classes like so:
>>x is Eq Ord Show

==Bug fixes and optimizations
Ela 0.11.1 provides a lot of bug fixes in classes and instances implementation, including some critical bugs
introduced with 0.11 release. It also provides some serious performance tweaks - especially in tail calls.

=Library changes
Ela Platform 2012.7 comes with a new version of Ela standard library that contains a lot of changes, including
changes in classes and module reorganization, and additions of new modules and functions.

==Numeric classes
Instead of a single numeric class `Num` from Ela 0.11, Ela 0.11.1 provides several numeric classes instead:
`Additive` for commutative operations, `Ring`, `Field` (division ring), `Modulo` (remainder and modulus functions).
These class collection is even more expanded by the `number` module, which additionally provides classes 
`Float`, `Integral`, `Transcendental` (transcendental functions), `Principal` (principal ideal domain functions)
and `Absolute`.//br
With new numeric classes the only common division operator is now defined in a `Field` class and implements
_real_ division for both integers and floats. Integer division if provided through `Integral` class (`div`, that
truncates towards negative infinity, and `quot`, that truncated towards zero). Function `quot` is equivalent to
what you get with integer division in C#.//br
More information on these classes is available in library reference.

==Enum class
`Enum` class now defines two additional methods - `enumFrom` and `enumFromTo` - which are in fact desugaring of
ranges syntax. A function `enumFrom` is used to generated "unbounded" ranges (normally, but not necessarily, 
infinite), and a function `enumFromTo` is used to generate bounded, finite ranges.
>>>enumFromTo 10 1 3

==Ix class
`Ix` class was refactored out in its old form and is now replaced by three classes, respectively: `Len` class,
that defines generic `length` function, `Ix` class, that defines `getValue` function, which is a function from
indices to values, and `Name` class, that defines functions `getField` and `isField`, that allows to obtain
an element from a container by a name.//br
An important change here is the distinction between indexing (`getValue`) and by-name access (`getField`). These
are two abstractions now and in order to support "dot syntax" (e.g. `foo.bar`) one shouldn't provide an implementation
for integer indexing or for `length` function. For example, modules in Ela are first class and support "dot syntax",
however, `length` or indexing do not have much meaning for them.//br
An operator `:` is still provided as a flipped version of `getValue` function.

==Type conversion classes
Now Ela provides type classes for most of standard data types. These classes have a definition like so:
>>class ListLike a where
>>      toList a
They are used to provide a way of extensible type conversions.

==StringBuilder data type
Now prelude defines an additional data type - `StringBuilder`. String builder is an immutable data type that is used
for effecient string concatenation. A instance of string builder can be "created" by simply referencing a `stringBuilder`
constant. In order to convert an instance of string builder to a string, one should use a `toString` function (from
`StringLike` class). An operator `+>`, defined in prelude, is used as a concatenation operator for string builder:
>>stringBuilder +> "One" +> "Two" +> "Three"

==New module: generic
A new `generic` module provides an experimental version of new Ela reflection API (see documentation for more
information) and default instances for most of standard Ela classes.

==New module: core
A new `core` module contains definition of known data types, such as `Maybe`, `Either` and `Ordering`, functions for
them and their instance. Please, refer to documentation for more details.

==Changes to list module
Many new functions were added to `list` module. However, some of the functions, including `init`, `last`, `foldl`,
`foldr`, `map`, `reverse` and `filter`, were moved to prelude.
