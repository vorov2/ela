#title What's new? (Ela Platform 2016.6)

=Overview
This release focuses on a redesign of exception handling in Ela and other notable features. It also comes with an update
to Ela standard library, Elide, Ela Console and documentation.

=Ela changes
==Deprecation of try/with construct
Starting from Ela 0.15 `try/with` construct is deprecated. You can still use it in your code, but Ela compiler would
generate a warning. However, you can still use `fail` function to raise errors. Also a new error handling strategy is
introduced with this release of Ela and Ela standard library.
==Handling errors
Raising an error with `fail` function would cause a program to terminate immediately, unless you use a deprecated
`try/with` construct. However, as long as Ela support non-strict execution, one can use a deferred failure strategy
by explicitly marking the `fail` function as lazy:
>>&fail "Unexpected error."
In this case an error would be raised only if you try to operate with the value returned by `fail` function. For example,
the following code wouldn't raise an error:
>>x = &fail "Unexpected error."
However, the following code would terminate a program with an exception:
>>x = &fail "Unexpected error."
>>y = x * 2
Sometimes you might need to check if an applied function was a success or a failure (e.g. returned a deferred "fail" like
shown in a previous section). In order to that you can use `isError` function, defined in a standard prelude like so:
>>>_ /. 0 = &fail "Division by zero."
>>>x /. y = x / y
>>>
>>>res = 12 /. 0
>>>
>>>isError res
In the example above an error is not raised and `isError` function returns `true`.//br
You can use a deferred `fail` in conjunction with `inError` function as a functional replacement for structured exception handling from
imperative languages.
==Suppress warnings
Ela 0.15 comes with a new binding attribute `nowarnings`. When specified it suppresses all warnings that otherwise would be
generated by a function. For example:
>>error # nowarnings
>>error obj =
>>  try force obj with
>>    str = str
This function won't generate a warning about `try/with` construct beign obsolete.
==Operator symbols
Now Ela allows to use `(,)`, `(;)` and `(#)` as operator symbols.//br
If an operator starts with a `(,)` it has one of the lowest priorities (the same as `($)`)
among other operators and left associativity.//br
If an operator starts with a `(;)` it has the same priority as `(,)` and left associativity.//br
If an operator starts with a `(#)` it has the same priority as `(@)` and right associativity.
==Debugger directives
Ela 0.15 includes an experimental feature - debugger directives. Currently the only supported directive is `trace`:
>>sum a b =
>>  let c = a + b in
>>  ##[trace point name]# c
It creates a so called "trace point". It is possible to specify an optional name for a trace point (like in an example above)
or to create a nameless trace point like so: `##[trace]#`.//br
This directive is processed as a regular Ela expression but is only compiled in debug mode (if you use Ela Console `elac.exe`,
you have to specify `-debug` command line key). When compiled a trace directive captures all local and captured values.//br
Ela virtual machine now allows to register trace point listeners using a new public method `AddTracePointListener`:
>var vm = new ElaMachine(asm);
>vm.AddTracePointListener(new TracePointListener());
A trace point listener should implement an interface `Ela.Debug.ITracePointListener`:
>public interface ITracePointListener
>{
>    void Trace(string tracePoint, LineSym line, IEnumerable<TraceVar> vars);
>}
Ela virtual machine than executes all registered listeners passing a name of a trace point, line information and a list of
all captured variables.//br
Both Ela Console (`elac.exe`) and Elide register their own trace point listeners. Elide provides a new `Trace` view and Ela Console
prints captured data to the standard output. For example, if we execute a function `sum` from a code sample above like so: `sum 12 4`,
the following data would be printed to console:
>*********************************************************
>Trace point: point name (Line: 11; Column: 7; Offset: 73)
>*********************************************************
>Locals:
>c = 16
>a = 12
>b = 4
>
>Captured:
>prelude = [module:prelude:3]
>sum = sum:*->*->*
>********************************************************
Currently trace points capture both local and non local variables (such as those declared in a outer function or in a global scope).//br
When a trace point listener is called captured values are not forced by Ela runtime environment. However, in the current implementation
both Elide and Ela Console try to force all thunks. For example, execution of the following code:
>>xs = 1::xs
>>a = a + 1
>>##[trace spec]#
in Ela Console would produce the following result:
>**************************************************
>Trace point: spec (Line: 4; Column: 1; Offset: 26)
>**************************************************
>Locals:
>prelude = [module:prelude:3]
>xs = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] (lazy)
>a = <evaluation timeout>
>**************************************************
As you can see Ela Console determines that one of the values is a lazy list and takes only the first 20 values of it - as a result there is
no non-termination in spite of the fact that list is infinite. However it cannot resolve a cycle definition of `a` and its evalution times out.//br
When compiled without additional debug information (without `-debug` switch in Ela Console) trace points are simply ignored by Ela compiler.
==Linker changes
Ela 0.15 comes with a new version of linker that contains important bug fix (Issue #1766, incorrect treatment of '.' in the names of folders) and an enhancement in module lookup logic (now linker first
tries to locate referenced module not in the startup directory of the linker itself but in the directory where a main module is located).

=Ela library changes
All modules in Ela library are updated to use new error handling strategy. Also library contains minor bug fixes, including fixes in
functions `readLines`, `readAllLines`, `forever` in `io` module, refactorings in `io` module, fix in `test` module 
(in function `regFun`, issue #1765).//br
Also this release of Ela library includes functions `takeBy`, `takeFailed` and `onlyFailed` in `espec` module for filtering test results.

=Elide changes
Ela Platform 2016.6 comes with a new version of Elide which offers an updated syntax highlighting for Ela as well as a new feature - 
now Elide remembers the scroll position and all selections made in open files.//br
Also Elide now includes a new `Trace` view (implemented as an "output" view in the bottom of the screen). This view display data from
trace points in the application and allows filtering based on the local/captured flag.

=Ela Console changes
Ela Platform 2016.6 is shipped with Ela Console 0.10, a new version of Ela core utility. This version contains several important fixes
and a support for the new trace listeners infrastructure.

=Documentation changes
Documentation in this release is updated according to the language changes. Also documentation now includes additional
code samples such as _Caeasar_ _cypher_, _RPN_ _Calculator_, _ABC_ _Blocks_ and _Langton's_ _Ant_. A _Prototype_ code
sample is now decomissioned (one can take a look at complete implementation of prototype based OOP in `object` module). Additionally
code samples directory is reorganized.
