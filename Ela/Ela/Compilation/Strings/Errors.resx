<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BangPatternNotValid" xml:space="preserve">
    <value>Bang pattern {0} is not valid in this context.</value>
  </data>
  <data name="ClassAlreadyDeclared" xml:space="preserve">
    <value>A module already defines a class '{0}'.</value>
  </data>
  <data name="DefaultMemberAlreadyExist" xml:space="preserve">
    <value>A default implementation for a member '{0}' of class '{1}' already exists.</value>
  </data>
  <data name="ElseMissing" xml:space="preserve">
    <value>A mandatory 'else' clause is missing. A conditional expression should be always terminated with an 'else' clause.</value>
  </data>
  <data name="ExtendsNoDefinition" xml:space="preserve">
    <value>Invalid definition of '{0}', all 'data' definitions require a body.</value>
  </data>
  <data name="FromEnumNotFound" xml:space="preserve">
    <value>Unable to find a definition of 'enumFrom' to generate an infinite range.</value>
  </data>
  <data name="FromEnumToNotFound" xml:space="preserve">
    <value>Unable to find a definition of 'enumFromTo' to generate a strict range.</value>
  </data>
  <data name="HeaderNotConnected" xml:space="preserve">
    <value>A binding header {0} doesn't correspond to any binding. A header should always preceed a binding.</value>
  </data>
  <data name="InvalidBuiltinBinding" xml:space="preserve">
    <value>Invalid binding for a built-in function implementation. Function head is missing.</value>
  </data>
  <data name="InvalidBuiltinClass" xml:space="preserve">
    <value>Invalid built-in class '{0}'.</value>
  </data>
  <data name="InvalidBuiltinClassDefinition" xml:space="preserve">
    <value>Invalid definition of a built-in class '{0}'.</value>
  </data>
  <data name="InvalidConstructor" xml:space="preserve">
    <value>Invalid constructor declaration {0}.</value>
  </data>
  <data name="InvalidConstructorParameter" xml:space="preserve">
    <value>Invalid parameter {0} for a constructor '{1}'.</value>
  </data>
  <data name="InvalidExpression" xml:space="preserve">
    <value>An expression '{0}' is not valid in this context.</value>
  </data>
  <data name="InvalidFunctionDeclaration" xml:space="preserve">
    <value>Invalid function declaration: {0}.</value>
  </data>
  <data name="InvalidMatchEntry" xml:space="preserve">
    <value>Match entry {0} is invalid.</value>
  </data>
  <data name="InvalidMemberSignature" xml:space="preserve">
    <value>A function '{0}' signature is invalid. Type parameter should be used in a signature at least once.</value>
  </data>
  <data name="InvalidPattern" xml:space="preserve">
    <value>Invalid pattern {0}.</value>
  </data>
  <data name="InvalidProgram" xml:space="preserve">
    <value>Invalid program body.</value>
  </data>
  <data name="InvalidQualident" xml:space="preserve">
    <value>An expression '{0}' is invalid in this context. A module alias is expected.</value>
  </data>
  <data name="InvalidTypeDefinition" xml:space="preserve">
    <value>Invalid type definition. Type name qualification is only allowed in 'data' declarations.</value>
  </data>
  <data name="InvalidVariant" xml:space="preserve">
    <value>Invalid variant declaration '{0}'. Only one value can be tagged. Use tuples to tag several values.</value>
  </data>
  <data name="MemberInvalid" xml:space="preserve">
    <value>A function '{0}' is not a member of a class '{1}'.</value>
  </data>
  <data name="MemberNoPatterns" xml:space="preserve">
    <value>A name of a class member cannot be inferred from a '{0}'. Patterns are not allowed in member bindings.</value>
  </data>
  <data name="MemberNotAll" xml:space="preserve">
    <value>Not all of the members for class '{0}' are declared in instance '{1}'.</value>
  </data>
  <data name="NoHindingSameScope" xml:space="preserve">
    <value>A conflicting definition of '{0}'. Shadowing of names in the same lexical scope is not allowed.</value>
  </data>
  <data name="PatternsTooFew" xml:space="preserve">
    <value>Not all of the patterns are specified in the entry {0}. Expected {1} pattern(s), found {2} pattern(s).</value>
  </data>
  <data name="PatternsTooMany" xml:space="preserve">
    <value>Too many patterns are specified in the entry {0}. Expected {1} pattern(s), found {2} pattern(s).</value>
  </data>
  <data name="PlaceholderNotValid" xml:space="preserve">
    <value>An expression '_' is not valid in this context.</value>
  </data>
  <data name="PrivateNameInModule" xml:space="preserve">
    <value>A name '{0}' from module '{1}' is marked as private.</value>
  </data>
  <data name="PrivateOnlyGlobal" xml:space="preserve">
    <value>A 'private' modifier is valid only on global bindings.</value>
  </data>
  <data name="SuccNotFound" xml:space="preserve">
    <value>Unable to find a definition of 'succ' to calculate stepping for a range.</value>
  </data>
  <data name="TooManyErrors" xml:space="preserve">
    <value>Too many errors.</value>
  </data>
  <data name="TypeAlreadyDeclared" xml:space="preserve">
    <value>A module already defines a type '{0}'.</value>
  </data>
  <data name="TypeHeaderNotConnected" xml:space="preserve">
    <value>A type header '{0}' should precede a type declaration.</value>
  </data>
  <data name="UnableDerive" xml:space="preserve">
    <value>Unable to automatically derive a class '{0}' for a data type '{1}'. A complete default instance of class '{0}' was not found.</value>
  </data>
  <data name="UnableExtendOpenType" xml:space="preserve">
    <value>Type '{0}' is not declared as open type, it is not possible to extend this type with new constructors.</value>
  </data>
  <data name="UndefinedName" xml:space="preserve">
    <value>A name '{0}' is not defined in a module or externally.</value>
  </data>
  <data name="UndefinedNameInModule" xml:space="preserve">
    <value>A module '{0}' doesn't have a name '{1}' in its export list.</value>
  </data>
  <data name="UndefinedType" xml:space="preserve">
    <value>Unknown type '{0}'.</value>
  </data>
  <data name="UnknownClass" xml:space="preserve">
    <value>Unknown class '{0}'.</value>
  </data>
</root>